---
title: "Tour de France data"
output: html_notebook
---

# SETUP
Load libraries.
```{r setup}
library(tidyverse)
library(rvest)
library(lubridate)
library(geosphere)
library(geonames)
library(maps)
library(mapproj)
```

# SCRAPE
Create vector of the Tour de France URLs from [Tour de France](https://histo.letour.fr/HISTO/fr/TDF/1903/etapes.html) site, where data is available from 1903 - 2018.
```{r url_list}
years <- seq(1903, 2018, 1)
url_base <- "https://histo.letour.fr/HISTO/fr/TDF/"
url_end <- "/etapes.html"
urls <- years %>%
  paste0(url_base, . , url_end)

data_init <- tibble(year = years, url_path = urls)

data_init
urls[1:20]
```

Define function to scrape and clean Tour de France data from one URL.
```{r scrape_clean}
scrape_clean <- function(url){
xml <- read_html(url) %>%
  html_node("table") %>% 
  html_table(fill=TRUE) %>%
  select(X1, X2, X3, X4) %>% 
  subset(X2 != "Étape") %>% 
  subset(X3 != "NA") %>%
  subset(X2 != "Date") %>%
  rename("stage" = X1, "date" = X2, "start" = X3, "end" = X4)
xml
}
```

Scrape data for every year.
```{r scrape}
data <- data_init %>%
  mutate(year_data = purrr::map(url_path, possibly(scrape_clean, "no data")))

data
```

# INITIAL CLEAN & TIDY 
Remove (war) years with no tour with new column `data_exists` (`TRUE` if there is data for tour in this year).
```{r has_data}
has_data <- function(ls){
  !has_element(ls, "no data")
}

data <- data %>%
        mutate(data_exists = map_lgl(year_data, has_data))

data

years_data <- data %>%
  select(year, data_exists)

years_data
```

Create new columns:

- `tour_stages` = number of stages for each year

- `tour_data` = stages for each year
```{r tour_data}
tour_data <- data %>%
  filter(data_exists) %>%
  mutate(n_stage = map_int(year_data, nrow))

tour_stages <- tour_data %>%
  select(year, n_stage)

filter(years_data, !data_exists)

tour_data <- tour_data %>%
  select(year, year_data) %>%
  unnest()

tour_data
```

# CLEAN STAGES
First check that year and stage define each row uniquely.
```{r check_stage}
tour_data %>%
  group_by(year, stage) %>%
  distinct() %>%
  summarise(n_duplicates = n()) %>%
  arrange(-n_duplicates)

list("n_rows" = nrow(tour_data), "n_unique_year_stage" = tour_data %>% select(year, stage) %>% distinct() %>% nrow())
```

The table below shows the unique entries for stage.
```{r display_stage}
unique(tour_data$stage)
```

Create separate fields: 

- stage type

- stage number

- sub-stage number

where 'prologue' stages have 0 for stage and substage numbers.

```{r clean_stage}
tour_data_clean <- tour_data %>%
  mutate(
  stage_clean = str_replace(stage, "^étape ", ""),
  stage_number = if_else(stage_clean == "prologue", 0L, as.integer(stage_clean)),
  sub_stage_number = if_else(stage_clean == "prologue", 0.00, round(as.double(stage_clean) - stage_number, digits = 2)),
  stage_type = if_else(stage_clean == "prologue", stage_clean, 
                       if_else(sub_stage_number > 0, "sub_stage", 
                               if_else(is_integer(stage_number), "main_stage", "other")
                               )
                       )
  ) %>%
  select(-stage, -stage_clean)

print("Values within stage_type:")
unique(tour_data_clean$stage_type)
print("Values within stage_number:")
unique(tour_data_clean$stage_number)
print("Values within sub_stage_type:")
unique(tour_data_clean$sub_stage_number)
```

Check that year stage number and sub-stage number define each row uniquely and create a `stage_id` column as a unique identifier.
```{r stage_id}
list("n_rows" = nrow(tour_data_clean), "n_unique" = tour_data_clean %>% select(year, stage_number, sub_stage_number) %>% distinct() %>% nrow())

tour_data_clean <- tour_data_clean %>%
  arrange(year, stage_number, sub_stage_number) %>%
  mutate(stage_id = year*1000 + stage_number + sub_stage_number)

print("number of unique stage ids")
length(unique(tour_data_clean$stage_id))
```

??? `list("n_rows" = nrow(tour_data), "n_unique_year_stage" = tour_data %>% group_by(year, stage) %>% distinct() %>% nrow())`

# CLEAN DATES

Clean date into date format, `NA` if blank. Table returns any rows where date is not blank and parsed date is `NA`. 
```{r clean_date}
tour_data_clean <- tour_data_clean %>%
  mutate(date_clean = parse_date(date, "%d/%m/%Y"))

tour_data_clean %>%
  filter(is.na(date_clean) & (nchar(date) > 0))
```

Check parsed date (date_clean) is consistent with the year column.
```{r check_date}
tour_data_clean %>%
  mutate(year_from_date = year(date_clean)) %>%
  filter(year_from_date != year)
```

There is one case where year is different, stage 16 in year 1987. Filter on year 1987 to investigate further.  It looks like the date should be 1987-07-16 not 1986-07-16.
```{r 1987_investigate}
filter(tour_data_clean, year == 1987, stage_number > 14 & stage_number < 18)
```

Check stages 13-19 for 1986.  There is a stage 16 for 1986 that has the correct date.
```{r 1986_investigate}
filter(tour_data_clean, year == 1986, stage_number > 14 & stage_number < 18)
```

Correct `date_clean` for stage 16 in 1987 to be 1987-07-16 not 1986-07-16.
```{r 1987_16_correction}
tour_data_clean <- tour_data_clean %>%
  mutate(date_clean = if_else( (year == 1987) & (stage_number == 16), parse_date("16/07/1987", "%d/%m/%Y"), date_clean)) %>%
  select(-date)

tour_data_clean %>%
  filter(year == 1987, stage_number > 14 & stage_number < 18) 
```

# CLEAN START AND END

First remove any blank spaces from the left or right of each of the start and end fields. Then check that there is a start and end location for every row. There is one row that doesn't have a start location, stage 13 in 1976.
```{r clean_start_end}
tour_data_clean <- tour_data_clean %>%
  mutate(start = trimws(start),
         end = trimws(end)) 

tour_data_clean%>%
  filter(nchar(start) == 0 | nchar(end) == 0)
```

A reasonable assumption is that stage 13 started where stage 12 ended.
```{r 1976_investigate}
filter(tour_data_clean, year == 1976, stage_number > 11 & stage_number < 15)
```

Edit any blank start locations to use end location of previous stage, and vice versa for blank end locations. This will return `NA` for start if start is blank for the first stage, and `NA` for end if end is blank for the last stage. Check to see if any still blank, and check particular case for 1976 stage 13.
```{r clean_start_end_2}
tour_data_clean <- tour_data_clean %>%
  group_by(year) %>%
  mutate(start = if_else(nchar(start) == 0, lag(end), start),
         end  = if_else(nchar(end) == 0, lead(start), end)
         ) %>%
  ungroup()

tour_data_clean%>%
  filter(nchar(start) == 0 | nchar(end) == 0 | is.na(start) | is.na(end))

filter(tour_data_clean, year == 1976, stage_number > 11 & stage_number < 15)
```

# CLEAN GPS COORDINATES

First transform data so that each row is location of tour, rather than a stage, using `gather()`. This means that each stage will have two rows instead of one. This also assumes that the each stage starts and finishes on the same day.
```{r stage_to_location}
tour_data_clean <- tour_data_clean %>%
  gather(start, end, key = "point", value = "location") %>%
  arrange(year, stage_number)
```

Now we want to add GPS coordinates for each start and end location. 

# ------ NEW GPS METHOD

Use geonames open source api to geocode each location.
```{r add_gps_geonames}
# Set options for geonames. Need to set host to be api.geonames.org as geonames package default is ws.geonames.org and all addresses have been changed by geonames to api.geonames.org instead of ws.geonames.org and the R geonaes package hasn't ben updated for this.
options(geonamesUsername="sancy8") 
options(geonamesHost="api.geonames.org")

# Define function to extract latitude and longitude from top search result from geonames api with place name of stage location, in EU, and in France with population above 15,000.
get_gps_15k <- function(x) {
  res <-
    GNsearch(
      name = x,
      maxRows = 1,
      country = "FR",
      country = "UK",
      country = "ES",
      country = "BE",
      country = "IE",
      country = "DE",
      country = "IT",
      country = "NL",
      country = "CH",
      country = "AD",
      country = "LU",
      country = "MC",
      cities = 'cities15000',
      continentCode = "EU"
    ) %>%
    select(lat, lng, name) %>%
    mutate(lng = as.double(lng), lat = as.double(lat))
  return(res)
}

# As above, but no constraint on population and with bias towards locations in France.
get_gps_all <- function(x) {
  res <-
    GNsearch(
      name = x,
      maxRows = 1,
      country = "FR",
      country = "UK",
      country = "ES",
      country = "BE",
      country = "IE",
      country = "DE",
      country = "IT",
      country = "NL",
      country = "CH",
      country = "AD",
      country = "LU",
      country = "MC",
      countryBias = "FR",
      continentCode = "EU"
    ) %>%
    select(lat, lng, name) %>%
    mutate(lng = as.double(lng), lat = as.double(lat))
  return(res)
}

# Get latitude and longitude coordinates for the unique locations in the Tour de France data.
loc_gps <- tour_data_clean %>%
  select(location) %>%
  distinct() %>%
  mutate(gps = purrr::map(location, possibly(get_gps_15k, "error")),
         gps = if_else(gps != "error", gps, purrr::map(location, possibly(get_gps_all, "error"))))

# Number of locations which failed to match
loc_gps %>%
  filter(gps == "error")

# Number of locations which failed to match
manual_rename <- loc_gps %>%
  filter(gps == "error")
```

For locations which do not match, look through and manually adjust location name and then search geonames using this location_manual.

```{r add_gps_manual}
manual_rename$location_manual <- c(
  "Brasschaat",
  "Aosta",
  "saint-jean-de-monts",
  "morzine",
  "Le Barcarès",
  "Sint Willebrord",
  "Bauné",
  "Super Besse",
  "Super Besse",
  "grospierres",
  "Eaux-Bonnes",
  "Montpon-Menesterol",
  "saint-justin",
  "Lourdes",
  "Malbuisson",
  "Saint-Orens-de-Gameville",
  "Saint-Valery-en-Caux",
  "Loudenvielle",
  "Enniscorthy",
  "Pech",
  "Régnié-Durette",
  "Loudenvielle",
  "Pla de Beret",
  "Beillé",
  "Loudenvielle",
  "Gourette",
  "Wallers",
  "Morez",
  "beauvoir-sur-mer",
  "charnizay",
  "Super Besse",
  "Serre-Chevalier",
  "Valfréjus",
  "Davézieux",
  "semnoz",
  "Maubourguet",
  "Arras",
  "bedous",
  "Paris",
  "Sainte-Marie-du-Mont",
  "Aspin-Aure",
  "Betlán",
  "salavas",
  "Villars-'les-Dombes",
  "Finhaut",
  "saint-gervais-les-bains",
  "Morez"
)

manual_rename <- manual_rename %>%
  mutate(gps = purrr::map(location_manual, possibly(get_gps_all, "error")))

manual_rename

loc_gps <- loc_gps %>%
  filter(gps != "error") %>%
  dplyr::bind_rows(select(manual_rename, -location_manual))

loc_gps %>%
  filter(gps == "error")
```

Extract latitude and longitude and name from gps list.
```{r extract_lat_long}
loc_gps <- loc_gps %>%
  filter(gps != "error") %>%
  mutate(lat = unlist(pluck(gps, "lat")),
         long = unlist(pluck(gps, "lng")),
         location_geonames = unlist(pluck(gps, "name"))) %>%
  select(-gps)
```

Map locations to see if any coordinates that are obviously wrong.
```{r map_gps}
world_map <- map_data(map = "world")

countries <-
  c("Austria",
    "Belgium",
    "France",
    "Germany",
    "Ireland",
    "Italy",
    "Luxembourg",
    "Netherlands",
    "Spain",
    "Switzerland",
    "UK")

borders_map <- map_data(map = "world", region = countries)

borders_plot <- ggplot() +
  geom_polygon(data = borders_map, aes(x = long, y = lat, group = group), fill = "#FEED00", colour = "#FDFEFE") +
  coord_map() +
  theme_void() +
  geom_point(data = loc_gps, aes(x = long, y = lat), size = 0.25, colour = "black")

borders_plot
```

There are some points in the East which look odd, double check these locations have been in the Tour de France and correct where neccessary.  Replot locations, location in east is Berlin, checked that Tour has been through.

```{r map_anomaly}
map_anomaly <- filter(loc_gps, long > 9.5)

map_anomaly$location_manual <- c("saarlouis", "Berlin", "zeeland") 

map_anomaly <- map_anomaly %>%
    mutate(gps = purrr::map(location_manual, possibly(get_gps_gnsearch, "error")),
           lat = unlist(pluck(gps, "lat")),
           long = unlist(pluck(gps, "lng")),
           location_geonames = unlist(pluck(gps, "name"))) %>%
  select(-gps, -location_manual)

# Replace anomalies with corrected values (where neccessary)
loc_gps <- loc_gps %>%
  filter(long <= 9.5) %>%
  bind_rows(map_anomaly)

# Replot chart
borders_plot <- ggplot() +
  geom_polygon(data = borders_map, aes(x = long, y = lat, group = group), fill = "#FEED00", colour = "#FDFEFE") +
  coord_map() +
  theme_void() +
  geom_point(data = loc_gps, aes(x = long, y = lat), size = 0.25, colour = "black")

borders_plot
```

Join lat and long coordinates to tour_data_clean.  Convert tour_data_clean to form one row per stage.
```{r join_lat_long}
tour_data_clean <- tour_data_clean %>%
  left_join(loc_gps, by = "location")

end_loc_link <- tour_data_clean %>%
  filter(point == "end") %>%
  select(stage_id, point:long) %>%
  rename(point_end = "point")

tour_data_stage_row <- tour_data_clean %>%
  select(-location_geonames) %>%
  mutate(point_end = "end") %>%
  left_join(end_loc_link, by = c("stage_id", "point_end")) %>%
  filter(point != "end") %>%
  select(-point, -point_end) %>%
  rename(start_loc = "location.x", start_lat = "lat.x", start_long = "long.x", end_loc = "location.y", end_lat = "lat.y", end_long = "long.y")

```

# CALCULATE DISTANCE BETWEEN START AND END OF STAGE

First **define function** to calculate distance between input latitude and longitude (from [here](https://blog.exploratory.io/calculating-distances-between-two-geo-coded-locations-358e65fcafae), but adapted to work with mutate rather than the exploratory package, ie return a vector of distances rather than one number). Distance is returned in metres.
```{r dist_func}
get_geo_distance = function(long1, lat1, long2, lat2) {
  loadNamespace("purrr")
  loadNamespace("geosphere")
  longlat1 = purrr::map2(long1, lat1, function(x,y) c(x,y))
  longlat2 = purrr::map2(long2, lat2, function(x,y) c(x,y))
  distance = purrr::map2(longlat1, longlat2, function(x,y) geosphere::distHaversine(x, y))
  
  unlist(distance)
}
```

Calculate distance between start and end locations and check that no distances greater than 500km

```{r recalc_dist}
tour_data_stage_row <- tour_data_stage_row %>%
  mutate(dist_start_end = get_geo_distance(start_long, start_lat, end_long, end_lat) / 1000)

# Summaries of where distance > 500km. Same as code in location_summary chunk
summary_loc <- tour_data_stage_row %>% 
  ungroup() %>%
  mutate(dist_gt_500km = if_else(dist_start_end > 500, "yes", "no")) 

summary_loc %>%
  select(stage_id, dist_gt_500km) %>%
  group_by(dist_gt_500km) %>%
  summarise(n_stages = n())

summary_loc %>%
  filter(dist_gt_500km == "yes")

errors_500km <- summary_loc %>%
  filter(dist_gt_500km == "yes") %>%
  select(start_loc, end_loc) %>%
  gather(start_loc, end_loc, key = "position", value = "location") %>% 
  select(location) %>%
  group_by(location) %>%
  summarise(n_stage_errors = n()) %>%
  arrange(-n_stage_errors)

errors_500km

output_errors <- tour_data_clean %>%
  filter(location %in% errors_500km$location) %>%
  select(location:location_geonames) %>%
  distinct()

write_csv(output_errors, "output_errors.csv")
```




######### TO DO - Fix locations that aren't working.

# SAVE
Save final data for next step: plotting!
```{r}
write_csv(tour_data_stage_row, "tour_routes.csv")
```